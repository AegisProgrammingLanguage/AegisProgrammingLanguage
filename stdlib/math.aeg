// ==========================================
//  AEGIS STANDARD LIBRARY - MATH MODULE
// ==========================================

// --- Constants ---

var PI = 3.1415926535
var E = 2.7182818284

// --- Basic Utilities ---

// Returns the absolute value of n
func abs(n) {
    if (n < 0) {
        return 0 - n
    }
    return n
}

// Returns the maximum of two numbers
func max(a, b) {
    if (a > b) { return a }
    return b
}

// Returns the minimum of two numbers
func min(a, b) {
    if (a < b) { return a }
    return b
}

// Returns true if n is even
func is_even(n) {
    return (n % 2) == 0
}

// Returns true if n is odd
func is_odd(n) {
    return (n % 2) != 0
}

// --- Arithmetic & Algebra ---

// Calculates base raised to the power of exponent (integer only)
func pow(base, exponent) {
    if (exponent == 0) { return 1 }
    if (exponent < 0) { return 0 } // Float support needed for negative exponent
    
    var result = 1
    var i = 0
    while (i < exponent) {
        var result = result * base
        var i = i + 1
    }
    return result
}

// Calculates the square root of n using Newton-Raphson method
// Approximation: x(n+1) = 0.5 * (x(n) + N / x(n))
func sqrt(n) {
    if (n < 0) { return -1 } // Error code for imaginary numbers
    if (n == 0) { return 0 }
    
    var x = n
    var i = 0
    // 10 iterations is usually enough for decent precision
    while (i < 10) {
        var x = 0.5 * (x + n / x)
        var i = i + 1
    }
    return x
}

// Calculates the Greatest Common Divisor (Euclidean algorithm)
func gcd(a, b) {
    while (b != 0) {
        var temp = b
        var b = a % b
        var a = temp
    }
    return a
}

// Calculates the Least Common Multiple
func lcm(a, b) {
    if (a == 0) { return 0 }
    if (b == 0) { return 0 }
    var prod = a * b
    return abs(prod) / gcd(a, b)
}

// --- Geometry (OOP) ---

// A 2D Vector class to handle coordinates
class Vector2(x, y) {
    
    // Calculate distance from (0,0)
    magnitude() {
        // sqrt(x^2 + y^2)
        var sq_sum = (this.x * this.x) + (this.y * this.y)
        return sqrt(sq_sum)
    }

    // Calculate distance to another Vector2 object
    distance_to(other) {
        var dx = this.x - other.x
        var dy = this.y - other.y
        return sqrt((dx * dx) + (dy * dy))
    }

    // Returns a string representation
    to_string() {
        return "(" + this.x + ", " + this.y + ")"
    }
    
    // Adds another vector to this one and returns a new Vector
    add(other) {
        var new_x = this.x + other.x
        var new_y = this.y + other.y
        return new Vector2(new_x, new_y)
    }
}
